//
// Module mopshub_readout_lib.elink_interface_rec_sm.fsm
//
// Created:
//          by - dcs.dcs (localhost)
//          at - 16:00:00 05/03/24
//
// Generated by Mentor Graphics' HDL Designer(TM) 2019.4 (Build 4)
//
`resetall
`timescale 1ns/10ps
module elink_interface_rec_sm( 
   // Port Declarations
   input   wire           abort,             // Upon receiving a reset message on the CANbus. FSM goes into a known state
   input   wire           can_id, 
   input   wire           clk,               // posedge
   input   wire           end_elink_proc, 
   input   wire           endwait, 
   input   wire           fifo_data_eop, 
   input   wire           fifo_data_sop, 
   input   wire           fifo_elink_rdy, 
   input   wire           fifo_packet_rdy, 
   input   wire           rst,               // synchronous low active
   input   wire           start_read_elink, 
   input   wire           timeoutrst,        // timeout reset signal to the state machine in case bridge controller is not respoding for a specified time
   output  reg     [4:0]  addr_read,         // request to caninterface block
   output  reg            buffer_elink_en, 
   output  reg            buffer_eth_en, 
   output  reg            buffer_tra_en, 
   output  reg            cs_eread, 
   output  reg            end_read_elink,    // request to bridge FSM 
   output  reg            entimeout,         // enable for timeout reset counter 
   output  reg            irq_elink_eth, 
   output  reg            irq_elink_tra, 
   output  reg     [7:0]  statedeb
);

//tmrg default triplicate
//tmrg tmr_error false
// Internal Declarations


// Module Declarations

// State encoding
parameter 
          ST_waittoact   = 5'd0,
          ST_reset       = 5'd1,
          store_RB2      = 5'd2,
          store_RB3      = 5'd3,
          store_RB4      = 5'd4,
          store_RB0      = 5'd5,
          RB1            = 5'd6,
          store_RB5      = 5'd7,
          store_RB6      = 5'd8,
          store_RB7      = 5'd9,
          store_RB8      = 5'd10,
          store_RB9      = 5'd11,
          ST_wait_eop    = 5'd12,
          ST_end_read_en = 5'd13,
          ST_Wait        = 5'd14,
          ST_en_buffer   = 5'd15,
          ST_wait_sop    = 5'd16,
          RB0            = 5'd17,
          ST_eth_buffer  = 5'd18,
          wait_irq       = 5'd19,
          irq_eth        = 5'd20,
          ST_endwait     = 5'd21;

reg [4:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   can_id, 
   current_state, 
   end_elink_proc, 
   fifo_data_eop, 
   fifo_data_sop, 
   fifo_elink_rdy, 
   fifo_packet_rdy, 
   rst, 
   start_read_elink
)
begin : next_state_block_proc
   case (current_state) 
      ST_waittoact: begin
         if (fifo_elink_rdy ==1)
            next_state = ST_wait_sop;
         else
            next_state = ST_waittoact;
      end
      ST_reset: begin
         if (rst == 1)
            next_state = ST_waittoact;
         else
            next_state = ST_reset;
      end
      store_RB2: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = store_RB3;
         else
            next_state = store_RB2;
      end
      store_RB3: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = store_RB4;
         else
            next_state = store_RB3;
      end
      store_RB4: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = store_RB5;
         else
            next_state = store_RB4;
      end
      store_RB0: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = RB1;
         else
            next_state = store_RB0;
      end
      RB1: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = store_RB2;
         else
            next_state = RB1;
      end
      store_RB5: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = store_RB6;
         else
            next_state = store_RB5;
      end
      store_RB6: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = store_RB7;
         else
            next_state = store_RB6;
      end
      store_RB7: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = store_RB8;
         else
            next_state = store_RB7;
      end
      store_RB8: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = store_RB9;
         else
            next_state = store_RB8;
      end
      store_RB9: begin
         if (fifo_elink_rdy && fifo_packet_rdy ==1)
            next_state = ST_wait_eop;
         else
            next_state = store_RB9;
      end
      ST_wait_eop: begin
         if (fifo_data_eop ==1)
            next_state = ST_eth_buffer;
         else
            next_state = ST_wait_eop;
      end
      ST_end_read_en: begin
         if (start_read_elink ==1)
            next_state = ST_en_buffer;
         else
            next_state = ST_end_read_en;
      end
      ST_Wait: begin
         if (end_elink_proc ==1'b1)
            next_state = ST_waittoact;
         else
            next_state = ST_Wait;
      end
      ST_en_buffer: begin
         next_state = ST_Wait;
      end
      ST_wait_sop: begin
         if (fifo_data_sop ==1)
            next_state = RB0;
         else
            next_state = ST_wait_sop;
      end
      RB0: begin
         if (can_id ==1)
            next_state = store_RB0;
         else
            next_state = RB0;
      end
      ST_eth_buffer: begin
         next_state = wait_irq;
      end
      wait_irq: begin
         next_state = irq_eth;
      end
      irq_eth: begin
         next_state = ST_end_read_en;
      end
      ST_endwait: begin
         next_state = ST_waittoact;
      end
      default: 
         next_state = ST_reset;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   current_state
)
begin : output_block_proc
   // Default Assignment
   addr_read = 5'b0;
   buffer_elink_en = 0;
   buffer_eth_en = 0;
   buffer_tra_en = 0;
   cs_eread = 0;
   end_read_elink = 0;
   entimeout = 1;
   irq_elink_eth = 0;
   irq_elink_tra = 0;

   // Combined Actions
   case (current_state) 
      ST_waittoact: begin
         entimeout = 0 ;
      end
      ST_reset: begin
         entimeout = 0 ;
      end
      store_RB2: begin
         addr_read = 5'h4;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      store_RB3: begin
         addr_read = 5'h5;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      store_RB4: begin
         addr_read = 5'h6;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      store_RB0: begin
         addr_read = 5'h2;
         buffer_elink_en =1;
         cs_eread =1;
      end
      RB1: begin
         addr_read = 5'h3;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      store_RB5: begin
         addr_read = 5'h7;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      store_RB6: begin
         addr_read = 5'h8;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      store_RB7: begin
         addr_read = 5'h9;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      store_RB8: begin
         addr_read = 5'hA;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      store_RB9: begin
         addr_read = 5'hB;
         cs_eread = 1 ;
         buffer_elink_en =1;
      end
      ST_wait_eop: begin
         addr_read = 5'h0;
         cs_eread = 1 ;
         buffer_elink_en =0;
      end
      ST_end_read_en: begin
         addr_read = 5'h0;
         irq_elink_tra =1'b1;
      end
      ST_Wait: begin
         addr_read = 5'h0;
         end_read_elink = 1 ;
      end
      ST_en_buffer: begin
         addr_read = 5'h0;
         buffer_tra_en =1;
      end
      ST_wait_sop: begin
         addr_read = 5'h0;
         cs_eread = 1 ;
      end
      RB0: begin
         addr_read = 5'h2;
         cs_eread =1;
      end
      ST_eth_buffer: begin
         addr_read = 5'h0;
         buffer_eth_en =1;
      end
      wait_irq: begin
         addr_read = 5'h0;
      end
      irq_eth: begin
         addr_read = 5'h0;
         irq_elink_eth =1'b1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= ST_reset;
   end
   else if (timeoutrst) begin
      current_state <= ST_reset;
   end
   else if (abort) begin
      current_state <= ST_endwait;
   end
   else if (endwait) begin
      current_state <= ST_reset;
   end
   else 
   begin
      current_state <= next_state;
   end
end // Clocked Block

// State-As-Output assignment
always @(current_state)
begin
   statedeb = 8'b0;
   statedeb[4:0] = current_state;
end

endmodule // elink_interface_rec_sm
